## rowkey 设计

### 1. 概念
key 存储的信息一般有两类：
1. 键本身存储的内同
2. 键的排列顺序

查询时最好提供查询的列族和查询时间戳，默认查询的时间戳为最新的，不提供时间戳也可以。  
列限定符（column qualifier）对性能影响不大，通过限定符筛选数据只会有小幅度的性能提升。  
值（value）是查询筛选时最后一个筛选条件，使用值筛选数据引起的新能提升与使用限定符时类似：系统需要检查每个单元格来确定是否满足用户的筛选条件。

### 2. 高表和宽表
在 Hbase 中如何存储自己的数据：通常情况下, Hbase 中的表可以设计高表（tall-narrow table）和宽表（flat-wide table）两类。
前者指表中列少而行多，后者则正好相反。

### 3. 部分键扫描
Hbase 可以根据实际需求，设计好 rowkey 后，根据具体的需求使用 scan 进行扫描操作。

### 4. 排序
hbase 数据的排序是根据 rowkey 来进行排序的，要将 rowkey 的长度设计到同样的长度，不够的
需要自己补充。然后根据需求，来生成 rowkey 进行排序，排序时是根据从左往有判断进行排序的。

### 5. 分页
用户可以在客户端添加 offset 和 limit 参数来筛选数据，也可以使用分页过滤器（PageFilter）或列分页过滤器（ColumnPaginationFIlter）
这两个过滤器来达到分页功能。

### 6.时间序列
当处理流式时间时，最常见的数据就是按时间序列组织的数据。这写数据的突出特点是它们的行键
都代表了事件发生的时间。由于 Hbase 的数据组织方式，这样的数据在存储是会出现一个问题：这些数据
会
被有序存储到一个特定的范围内，也就是一个有特定起始键和停止键的 region 中。由于一个 region 智能由一个服务器管理，所以所有的更新都会集中在一台服务器上。
这会导致系统产生读写热点，并由于写入数据过分集中而导致整个系统性能下降。  
要解决这个问题，用户需要想办法将数据分散到所有的 region 服务器上。有很多方法可以达到这个目的。如：
#### 1. salting 方式（加盐）
用户可以使用 salting 前缀来保证数据分散到所有 region 服务器。例如：
```
byte prefix = (byte)(Long.hashCode(timestamp) % <number of region servers)
byte[] rowkey = Bytes.add(Bytes.toBytes(prefix),Bytes.toBytes(timestamp))
```
这个公式将产生足够的前缀数以确保将数据分散到所有 region 服务器中去。当然这个
公式假定服务器数目固定，如果用户的集群规模可能扩大就应当将前缀数翻倍。  
这样做的缺点是当用户要扫描一个连续的范围时，可能需要对每个 region 服务器发起请求（因为之前连续
的数据，现在已经分散到不同的服务器中）。这样也会带来好处，用户可以多线程并行地读取数据。

#### 2. 字段交换/提升权重
用户可以将时间戳字段移开或添加其他字段作为前缀。这样做其实是想利用组合行键的思想来让
连续递增的时间戳在行键中的位置从第一位变到第二位。  
如果用户设计的行键已经包含多个字段了，则可以调整他们的位置。如果行键只包含了时间戳，则
用户应当将其他字段从列键或值中提取出来，然后放到行键的前端。  
将时间戳从组合键的左边向右移动也有缺点：用户能访问数据，尤其是时间范围内的数据，并使用一个
给定的字段。

#### 3. 随机化
另一种完全不同的方式是将行键随机化，例如：
```
byte[] rowkey = MD5(timestamp)
```
采用 MD5 之类的散列函数能将行键分散到所有的 region 服务器上。对于时间连续的数据，这种方法明显不是个好方法。
因为随机化之后，用户将不能再按时间范围数据。  
另一方面，由于用户可以用散列的方式重新生成行键，随机化的方式很适合每次读取一行数据的应用。如果用户的数据不需要
连续扫描而只需要随机读取，用户就可以使用这种策略。  


简单总结以上方式后，会发现在优化读写性能的同时找到正确的平衡点并不是一件简单的事情。
它关系到用户的数据访问模式，该模式最终决定了用户如何设计行键的结构。  
使用 salt 前缀或将某些不是连续取值的逐渐字段提前，可以使分散写压力并提高写入性能，同时扫描连续的
键子集也可以提高度性能。但是如果用户只需要随机读取数据，那么随机行键就更有用，因为它能完全避免某个 region
成为读写热点。  

### 7. 时间顺序关系
以上数据都会按照产生的时间顺序以独立行插入到 Hbase 中，但是也可以使用另一种方式，即将新的事件以发生时间为列进行插入。
因为列在 Hbase 中是按列族组织的，所以每个列族下的列可以作为一个辅助索引单独进行排序，如果 RDBMS。虽然这不是推荐的设计模式，
但少量的索引可能正是用户所需要的。

注意不要为一张表设置过多的列族，特别是当数据两大的列族和数据量小的列族混用（大小指的是存储的数据量）。
